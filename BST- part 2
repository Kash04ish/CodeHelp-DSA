1. Two Sum in a BST (0:34)

void inorder(TreeNode* root, vector& inorderval) {
    if (root == NULL) {
        return;
    }

    inorder(root->left, inorderval);
    inorderval.push_back(root->data);
    inorder(root->right, inorderval);
}

bool twoSumBST(TreeNode* root, int target) {
    vector inorderval;
    inorder(root, inorderval); // Call to populate the vector

    int i = 0;
    int j = inorderval.size() - 1;

    while (i < j) {
        int sum = inorderval[i] + inorderval[j];
        if (sum == target) {
            return true;
        } else if (sum > target) {
            j--;
        } else {
            i++;
        }
    }
    return false;
}


2. Flatten BST to a Sorted Linked List (11:46)

// Assuming TreeNode structure is available as in the video
// struct TreeNode {
//     int data;
//     TreeNode *left;
//     TreeNode *right;
// };

void inorder(TreeNode* root, vector& inorderval) {
    if (root == NULL) {
        return;
    }
    inorder(root->left, inorderval);
    inorderval.push_back(root->data);
    inorder(root->right, inorderval);
}

TreeNode* flattenBST(TreeNode* root) {
    vector inorderval;
    inorder(root, inorderval);

    if (inorderval.empty()) { // Handle empty tree case
        return NULL;
    }

    TreeNode* newRoot = new TreeNode(inorderval[0]);
    TreeNode* curr = newRoot;

    for (int i = 1; i < inorderval.size(); i++) {
        TreeNode* temp = new TreeNode(inorderval[i]);
        curr->left = NULL;
        curr->right = temp;
        curr = temp;
    }

    // Set left and right of the last node to NULL
    curr->left = NULL;
    curr->right = NULL;

    return newRoot;
}



3. Normal BST to Balanced BST (21:05)

void inorder(TreeNode* root, vector& inorderval) {
    if (root == NULL) {
        return;
    }
    inorder(root->left, inorderval);
    inorderval.push_back(root->data);
    inorder(root->right, inorderval);
}

TreeNode* inorderToBST(vector& in, int s, int e) {
    if (s > e) {
        return NULL;
    }

    int mid = (s + e) / 2;
    TreeNode* root = new TreeNode(in[mid]);

    root->left = inorderToBST(in, s, mid - 1);
    root->right = inorderToBST(in, mid + 1, e);

    return root;
}

TreeNode* balancedBST(TreeNode* root) {
    vector inorderval;
    inorder(root, inorderval);

    return inorderToBST(inorderval, 0, inorderval.size() - 1);
}


4. BST from Preorder (32:24)

// Assuming TreeNode structure is available
// struct TreeNode {
//     int data;
//     TreeNode *left;
//     TreeNode *right;
// };

TreeNode* solve(vector& preorder, int& i, int mini, int maxi) {
    if (i >= preorder.size()) {
        return NULL;
    }

    // Check if the current element is within the valid range
    if (preorder[i] < mini || preorder[i] > maxi) {
        return NULL;
    }

    // Create node if it's within range
    TreeNode* root = new TreeNode(preorder[i++]); // Increment i after using it

    // Recursively build left and right subtrees
    // For left subtree, the current node's value becomes the new maximum limit
    root->left = solve(preorder, i, mini, root->data);
    // For right subtree, the current node's value becomes the new minimum limit
    root->right = solve(preorder, i, root->data, maxi);

    return root;
}

TreeNode* buildBSTFromPreorder(vector& preorder) {
    int i = 0; // Index for traversing the preorder array
    // Start with the widest possible range for the root node
    return solve(preorder, i, INT_MIN, INT_MAX);
}
